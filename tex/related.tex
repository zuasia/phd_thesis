%!TEX root=paper.tex

\section{Related Work}
\label{sec:related}

\paragraph{Software Support for Web Optimizations} Most prior research focus on parallelizing browser tasks, such as parsing, CSS selection, etc.~\cite{ParallelBrowser, FTL, UCI, Parabix}. Although such parallelized algorithms can achieve speedups ranging from 4X to 80X for various browsing tasks, they typically do not scale well beyond four cores with the expense of potential energy inefficiency. Thus, while parallelization has potential in desktop systems, it is less favorable for mobile Web computing.

Thiagarajan~et al.~\cite{www-battery} break the Web browser's energy consumption into coarser-grained elements, such as CSS and Javascript behavior, and identify a few system- and application-level optimizations to improve the energy consumption of mobile Web browsing.  The optimizations they recommend, such as reorganizing JavaScript files and removing unnecessary CSS rules, are orthogonal and complementary to our webpage prediction and scheduling work.
%Other works analyze the power/energy consumption of the entire smartphone\cite{Carroll, Eprof, JamesHotchip}, whereas we focus on improving the energy-efficiency of the mobile processor in response to the demand for high-performance.

Another portion of software-level optimizations focuses on improving the execution model of the Web browser through asynchronous/multiprocess rendering, resource prefetching, smarter browser caching, etc.~\cite{pocketweb, Adrenaline, smart-caching, webkit2, firefox-spec_parsing}. All these techniques are orthogonal and can be integrated with my proposal, which primarily focused on the core rendering engine of a Web browser.

\paragraph{Hardware Support for Web Optimizations} Similar to \webcore, SiChrome~\cite{SiChrome} performs aggressive specializations that map much of the Chrome browser into silicon, and achieves EDP improvement. The key difference is that we retain general-purpose programmability while still being energy efficient. Also, our Pareto-optimal analysis provides a more generic optimization view than the EDP-based evaluation.

ESP~\cite{esp} and EFetch~\cite{efetch} also propose specialized hardware structures on top of general-purpose cores to improve the performance and energy efficient of Web applications. They view Web application execution has a sequence of events while \webcore views Web application execution has a mix of different kernels. Both views are complementary in that per-event execution can benefit from kernel-level improvement that \webcore provides and vice versa.

\paragraph{Single ISA Heterogeneous Scheduling} The particular implementation of \greenweb runtime is an example of utilizing single-ISA heterogeneous systems for trading off performance with energy~\cite{single-ISA}. Nvidia's Kal-El~\cite{Tegra3} is a single-ISA heterogeneous system that integrates four high-frequency cores with one low-frequency core. ARM's proposed big.LITTLE system~\cite{big.little} contains a out-of-order Cortex-A15 processor and an in-order Cortex-A7 processor. ACMP architecture is already widely adopted in today's mobile SoCs shipped by major vendors. We expect our \webrt implementation to be readily applicable on commodity mobile hardware.

\webrt's prediction-based scheduling technique is similar to other recent heterogeneous scheduling proposals, such as PIE~\cite{PIE}. However, instead of relying on (micro)architecture- and system-level statistics for prediction, we capture the complex behavior of webpage characteristics using regression modeling, and accurately predict the webpage load time and energy consumption.

\paragraph{Language Support for Web Performance} The Web community has a long tradition of providing language extensions that allow developers to specify ``hints'' for browsers. The focus, however, has been primarily on \textit{performance} optimizations. \greenweb, to the best of our knowledge, is the first Web language extension that specifically targets \textit{energy}.

The most classical example of performance hint is link prefetch~\cite{linkprefetch}, which lets Web developers use an HTML tag to specify that a particular link will likely be fetched in the near future. With such information, a Web browser could prefetch the link when there are no on-demand network requests. Another example is the CSS \texttt{willChange} property~\cite{csswillchange}, which hints browsers about what visual changes to expect from an element so that the browser could perform a computationally intensive task ahead of time. Similar to \texttt{willChange}, \greenweb introduces a new CSS property \texttt{onevent-qos}, which allows providing QoS-related hints.

\paragraph{Language Support for Energy Efficiency} Language support for energy-efficiency has recently become a major research thrust. Most work targets approximate computing and sensor-based applications. To the best of our knowledge, this is the first work that focuses on Web applications. Green~\cite{green} provides APIs that let developers specify approximate versions of a function and QoS loss constraints. EnerJ~\cite{enerJ} takes the language support for approximate computing a step further by designing a general type system. These language frameworks could be applicable if sources of approximation in Web applications are identified, which however is beyond our scope. LAB~\cite{lab} identifies latency, accuracy, and battery as fundamental abstractions for improving energy-efficiency in sensor-based applications. Similarly, \greenweb identifies the QoS type and QoS target abstractions for enabling energy-efficient Web applications.

%Besides targeting different application domains, these language frameworks all require developers to manually annotate applications. We show that \greenweb annotations can be automatically applied without programmer intervention.

%\paragraph{Web Browser Workload Characterization} BBench performs microarchitecture-level characterization of the Android browser using 11 websites~\cite{BBench}. We treat webpages, rather than the web browser, as the workload. Moreover, we mine 5,000 hot webpages to identify and quantify the inherent variance in webpages more rigorously, and correlate the webpage variance to the difference in webpage load time and energy.
%
%Butkiewicz et al.~\cite{PageComplexity} characterizes the complexity of different webpages. They construct a model for webpage load time considering server and network effects. Instead, we consider both load time and energy usage on the client side of mobile web browsing, and we perform webpage-aware scheduling on a heterogeneous system using even more fine-grained prediction models.
%
%MobileBench~\cite{mobilebench} characterizes the performance impact of various microarchitecture features on mobile workloads. We quantify the performance-energy trade-off, and focus specifically on Web applications. Complementary to our DSE, MobileBench results show that more aggressive customizations of other microarchitecture structures such as the prefetcher are worth exploring.

%\paragraph{JavaScript} JavaScript is important in Web applications. JavaScript code is most often executed after the webpage is loaded. Google recommends that, to improve performance (especially in mobile browsing), all JavaScript processing should be deferred until the webpage load finishes~\cite{google-fast_mobile}. Proposals that speculatively process JavaScript~\cite{Crom, Adrenaline, webworker} further separate JavaScript from webpage load. In addition, as pointed out in~\cite{JSMeter}, a large portion of JavaScript code is either computationally intensive~\cite{SunSpider, V8} or an intensive stress on the memory management system. They require optimizations on the Just-In-Time (JIT) engine, programming model, or the garbage collector (GC)~\cite{ParaScript, rivertrail, YinYang}, all of which are beyond the scope of our work. Thus, our focus and mechanism in this paper are largely independent of JavaScript execution and its browser engine performance.

